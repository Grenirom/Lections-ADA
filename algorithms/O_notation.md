Big O notation

Это нотация для описания сложности алгоритма(используя подсчет количества операций)

O(1)
примеры алгоритмов, занимающих O(1):

num = [1, 2, 3, 4, 5]
print(num[0])

dict_ = {'a': 1, 'b':2, 'c': 3}
print(dict_['a'])

ДЛЯ ДАННЫХ АЛГОРИТМОВ(ВЫВОД ЗНАЧЕНИЯ ПО ИНДЕКСУ ИЛИ КЛЮЧУ), КОЛИЧЕСТВО ДЕЙСТВИЙ ВСЕГДА БУДЕТ 1. ДАЖЕ ЕСЛИ ЭЛЕМЕНТОВ В СПИСКЕ ИЛИ СЛОВАРЕ БУДЕТ 1000


O(n)

Если же мы хотим сделать обычный линейный поиск, то здесь кол-во операций зависит от количества элементов в итерируемом объекте

nums =[1,2,3,4,5]
target = 5
for i in nums:
    if i == target:
        return i

O(n2)
Чаще всего, это алгоритмы, которые итерируют объект, и внутри каждой итерации снова его итерируют. Возьмем не самый лучший алгоритм поиска дубликатов в списке

nums = [1,2,3,4,5,5]

def algorithm(nums):
    for i in range(len(nums)):
        num1 = nums[i]
        for j in range(len(nums)):
            num2 = nums[j] 
            if i == j:
                continue # переходим к следующему num2 числу, если мы взяли одно и то же число для num1 и num2
            if num1 == num2:
                return True
    return False

algorithm(nums)

Со списком в 6 элементов, наш алгоритм выполнит 30 операций в худшем случае (если дубликатов нет), если у нас будет 100 элементов, то операций будет 10000

O(log n)
Один из самых быстрых алгоритмов